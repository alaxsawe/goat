package goat

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"log"
	"net"
	"net/url"
	"strconv"
	"strings"
	"sync/atomic"
)

// Handshake for UDP tracker protocol
const udpInitID = 4497486125440

// Handle incoming UDP connections and return response
func handleUDP(l *net.UDPConn, udpDoneChan chan bool) {
	// Create shutdown function
	go func(l *net.UDPConn, udpDoneChan chan bool) {
		// Wait for done signal
		<-static.ShutdownChan

		// Close listener
		if err := l.Close(); err != nil {
			log.Println(err.Error())
		}

		log.Println("UDP listener stopped")
		udpDoneChan <- true
	}(l, udpDoneChan)

	// Count incoming connections
	atomic.AddInt64(&static.UDP.Current, 1)
	atomic.AddInt64(&static.UDP.Total, 1)

	first := true
	for {
		buf := make([]byte, 2048)
		rlen, addr, err := l.ReadFromUDP(buf)

		// Triggered on graceful shutdown
		if err != nil {
			return
		}

		// Verify length is at least 16 bytes
		if rlen < 16 {
			log.Println("Invalid length")
			continue
		}

		// Current connection ID (initially handshake, then generated by tracker)
		connID := binary.BigEndian.Uint64(buf[0:8])
		// Action integer (connect: 0, announce: 1)
		action := binary.BigEndian.Uint32(buf[8:12])
		// Transaction ID, to match between requests
		transID := buf[12:16]

		// On first run, verify valid connection ID
		if first {
			if connID != udpInitID {
				log.Println("Invalid connection handshake")
				_, err = l.WriteToUDP(udpTrackerError("Invalid connection handshake", transID), addr)
				if err != nil {
					log.Println(err.Error())
					return
				}
				continue
			}
			first = false
		}

		// Action switch
		switch action {
		// Connect
		case 0:
			res := bytes.NewBuffer(make([]byte, 0))

			// Action
			err = binary.Write(res, binary.BigEndian, uint32(0))
			if err != nil {
				log.Println(err.Error())
				return
			}

			// Transaction ID
			err = binary.Write(res, binary.BigEndian, transID)
			if err != nil {
				log.Println(err.Error())
				return
			}

			// Connection ID, generated for this session
			err = binary.Write(res, binary.BigEndian, uint64(randRange(0, 1000000000)))
			if err != nil {
				log.Println(err.Error())
				return
			}

			_, err := l.WriteToUDP(res.Bytes(), addr)
			if err != nil {
				log.Println(err.Error())
				return
			}

			continue
		// Announce
		case 1:
			query := url.Values{}

			// Ignoring these for now, because clients function sanely without them
			// Connection ID: buf[0:8]
			// Action: buf[8:12]

			// Mark client as UDP
			query.Set("udp", "1")

			// Transaction ID
			transID := buf[12:16]

			// Info hash
			query.Set("info_hash", string(buf[16:36]))

			// Skipped: peer_id: buf[36:56]

			// Downloaded
			t, err := strconv.ParseInt(hex.EncodeToString(buf[56:64]), 16, 64)
			if err != nil {
				log.Println(err.Error())
				return
			}
			query.Set("downloaded", strconv.FormatInt(t, 10))

			// Left
			t, err = strconv.ParseInt(hex.EncodeToString(buf[64:72]), 16, 64)
			if err != nil {
				log.Println(err.Error())
				return
			}
			query.Set("left", strconv.FormatInt(t, 10))

			// Uploaded
			t, err = strconv.ParseInt(hex.EncodeToString(buf[72:80]), 16, 64)
			if err != nil {
				log.Println(err.Error())
				return
			}
			query.Set("uploaded", strconv.FormatInt(t, 10))

			// Event
			t, err = strconv.ParseInt(hex.EncodeToString(buf[80:84]), 16, 32)
			if err != nil {
				log.Println(err.Error())
				return
			}
			event := strconv.FormatInt(t, 10)

			// Convert event to actual string
			switch event {
			case "0":
				query.Set("event", "")
			case "1":
				query.Set("event", "completed")
			case "2":
				query.Set("event", "started")
			case "3":
				query.Set("event", "stopped")
			}

			// IP address
			t, err = strconv.ParseInt(hex.EncodeToString(buf[84:88]), 16, 32)
			if err != nil {
				log.Println(err.Error())
				return
			}
			query.Set("ip", strconv.FormatInt(t, 10))

			// If no IP address set, use the UDP source
			if query.Get("ip") == "0" {
				query.Set("ip", strings.Split(addr.String(), ":")[0])
			}

			// Key
			query.Set("key", hex.EncodeToString(buf[88:92]))

			// Numwant
			query.Set("numwant", hex.EncodeToString(buf[92:96]))

			// If numwant is hex max value, default to 50
			if query.Get("numwant") == "ffffffff" {
				query.Set("numwant", "50")
			}

			// Port
			t, err = strconv.ParseInt(hex.EncodeToString(buf[96:98]), 16, 32)
			if err != nil {
				log.Println(err.Error())
				return
			}
			query.Set("port", strconv.FormatInt(t, 10))

			// Trigger an anonymous announce
			_, err = l.WriteToUDP(trackerAnnounce(userRecord{}, query, transID), addr)
			if err != nil {
				log.Println(err.Error())
				return
			}
		default:
			log.Println("Invalid action")
			continue
		}
	}
}
